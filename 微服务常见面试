nacos 服务启动命令：startup.cmd -m standalone
test
springclud 服务注册  nacos（+配置中心）  eureka
            负载均衡 ribbon负载均衡 自定义负载均衡
            熔断、降级  hystrix、sentinel
            监控 skywalking
            远程调用 feign
            网关： gateway /zuul
业务相关：
    限流  流桶算法、令牌桶算法
    分布式事务 分布式理论CAP、base 分布式事务解决方案、seata
    分布式服务接口幂等
    分布式任务调度  xxl-job
服务注册与发现是什么意思？springcloud如何实现注册发现；
    前面有
  负载均衡如何使用？
    前面有
  什么是服务雪崩？怎么解决这个问题？
    一个A服务挂了之后，服务B继续调用失败*(连接没有释放，但是tomcat连接数是固定的)，导致B也挂了，最终导致整个链路服务都失败的情况
    一个服务失败，导致整个服务链条服务都失败情况
  解决雪崩问题几种方式？ 高并发、网络问题
        1、超时处理（缓解）；设定超时时间（接口请求时间），请求超过一定时间没有相应就返回错误信息，不会无休止等待
        2、线程隔离（舱壁模式）: 限定每个业务能使用的线程数，避免耗尽tomat资源，
        3、熔断降级模式： 由熔断器统计业务执行异常比例，超过阈值胡熔断该业务，拦截访问该业务一切请求。
        4、流量控制（起到预防作用。使用sentinel）；限制业务访问qps(高并发)，避免服务因流量突增而故障。

  熔断降级（解决）  hystix
    服务降级： 服务中有个接口失败了，给予提示”“  在Feign发起远程接口调用时候，设置一个fallback进行降级处理
    服务熔断： 默认关闭，在引导类上注解开启。 检测到10s请求失败超过百分之50%，就触发熔断，所有请求都不可用。之后每隔5s尝试请求，失败继续关闭，成功则恢复正常请求
  限流（预防）
    并发大、用户恶意刷接口
    方式：tomcat 设置组大连接数
        nginx*：限流方式
            控制速率（突发流量、漏桶算法）：比如有100个请求进来了，放到桶中（多余的可以等待或者丢弃），
                    然后以固定的速率漏出请求
            控制并发连接数：
                    限制单个ip连接数和并发连接总数
        geteway 网关*：令牌算法（令牌桶算法）  在微服务路由设置添加局部过滤器RequestRatelIMITER
            以固定速度生成令牌，放在桶里面，请求需要到令牌桶中申请令牌，有令牌的进行服务，没有的被阻塞或者丢弃
            可能超出令牌生成效率。
            可以根据ip路径进行限流
        自定义拦截器

CAP 定理：
    分布式系统有三个指标，Consistency 一致性、高可用性、分区（Partition）容错性。分布式系统无法同时满足这三个指标，这个结论就是CAP定理
    一致性(C)： 用户访问集群任意节点，得到数据必须一样 （如主从复制）
    可用性(A)：用户访问集群任意节点，必须得到响应，而不是超时或者拒绝
    分区(P)：因为网络故障或者其他原因导致分布式系统中部分节点与其他节点失去连接，形成独立分区
    容错性：在集群出现分区时，整个系统也要持续对外提供服务。

     因为分布式系统节点之间肯定是需要网络连接的，所以分区(p)肯定存在，系统的一致性和可用性无法同时满足
     如果保证访问的高可用性（A）,可以持续对外服务，就不能保证一直性（c） -> AP
     如果保证访问的一致性(C),就要放弃高可用性  -》 CP
Base理论 :
    base 理论是对CAP的一种解决思路，包含三个思想：
    basiclly available （基本可用）：分布式系统出现故障时，允许损失部分高可用，既保证核心可用
    soft state （软状态）： 在一定时间内，允许出现中间状态，比如临时改变不一致状态
    Eventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致
    最终一致性；各分支事务分别执行并提交，如果有不一致情况，想办法回复数据
    强一致性：各分支事务执行完后不要提交，等待彼此结束，而后统一提交或回滚
分布式事务解决方案：
    微服务远程调用就存在分布式事务问题。
    解决方案：1、Seata框架（XA、AT、TCC模式）
            2、MQ
      Seata框架 事务管理重要角色：
        TC:
        TM:
        RM: 资源护管理器。（每个rm就是一个微服务）
     mq： 在A服务写数据时候，需要在同一事物内发送消息到另外一个事务，异步，性能最好



分布式服务接口幂等性如何设计？
 幂等：多次调用方法或者接口不会改变业务状态，课保证重复调用结果和单次调用结果一样
    场景：用户重复点击、mq消费重复、应用使用失败或超时重试机制
    接口：get 查询  天然幂等
        post 新增操作 不是幂等
        put 更新 是幂等，增量操作不是幂等
        delete 更具唯一值 是幂等
  解决方式： 1、数据库唯一索引 新增
            2、token+redis （性能较好）
                第一个请求处理时候生成唯一的token，放到redis中，返回给前段
                真正发起业务请求时，判断是否存在token 存在就处理业务，并且删除token，这样保证了幂等。
            3、分布式锁（性能低）。  redis setnx
分布式任务调度：？
    使用xxl-job。
        解决：1、解决集群任务重复执行问题
            2、cron表达式定义灵活
            3、定时任务失败，重试和统计
            4、任务量大，分片执行
        路由策略有哪些？ 实例1  实例2   任务1 任务2  任务3 任务4
             Failover*(故障转移) （让健康的实例去执行任务）  轮询*、随机、first last 固定找第一个（最后）机器、
             Sharding_broadcast*（分片广播），广播触发对应集群所有机器执行一次任务，同时系统自动传递分片参数
             一致hash*（consistent_hash）：每个任务按照hash算法固定选择某一台执行
             least_frequently_used 最不经常使用机器优先  最近最久未使用
        任务执行失败怎么解决？
            故障转移+故障设置（设置失效重试次数）
            然后查询日志分析（可视化页面有），也可以设置邮件告警
        如果有大数据量任务同时都需要执行，怎么解决？
            集群路由策略：分片广播模式 +
            代码上获取分片总数和当前分片，通过取模方式找到分摊到各个实例


spi  https://blog.csdn.net/qq_42651904/article/details/116091149





order-service
user-service





